<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>JustinFX.com</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://justinfx.com/tags/c&#43;&#43;/index.xml</link>
    <language>en-us</language>
    
    <copyright>2018 Justin Israel</copyright>
    <updated>2006-01-02 15:04:05 &#43;0000 MST</updated>
    
    
    <item>
      <title>C&#43;&#43; Bindings For A Go Library</title>
      <link>http://justinfx.com/2016/05/14/cpp-bindings-for-go/</link>
      <pubDate>2006-01-02 15:04:05 &#43;0000 MST</pubDate>
      
      <guid>http://justinfx.com/2016/05/14/cpp-bindings-for-go/</guid>
      <description>&lt;p&gt;This is an overview describing my approach to creating C++ bindings around a Go library.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-bit-about-wrapping-c-c&#34;&gt;A bit about wrapping C/C++&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve had some past experience in writing cgo bindings on top of C and C++ libraries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/justinfx/openimageigo&#34;&gt;OpenImageigo&lt;/a&gt; and &lt;a href=&#34;https://github.com/justinfx/opencolorigo&#34;&gt;OpenColorigo&lt;/a&gt; - Color pipeline and image manipulation and conversion libraries relevant to the Visual Effects industry. These cgo libraries wrap C++.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Contributor&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gographics/imagick&#34;&gt;imagick&lt;/a&gt; - Bindings on top of the C-API for ImageMagick; Image manipulation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wkschwartz/pigosat&#34;&gt;pigosat&lt;/a&gt; - Bindings on top of Picosat C-API; Satisfiability solver.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C libraries are more straight-forward to wrap, because Go can access them directly. C++, on the other hand, requires a &amp;ldquo;shim&amp;rdquo; layer written in C. This layer has to handle the calls between Go and the target C++ library. An example would be to treat a C++ class as an opaque pointer and provide C functions that accept the pointer and delegate to the C++ methods. Or to convert between vectors and arrays:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ref:&lt;/em&gt; &lt;a href=&#34;https://github.com/justinfx/openimageigo/blob/master/cpp/oiio.h&#34;&gt;&lt;em&gt;github.com/justinfx/openimageigo/cpp/oiio.h&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// oiio.h&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\#&lt;/span&gt;ifdef __cplusplus
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; {
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\#&lt;/span&gt;endif

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;void&lt;/span&gt; ImageInput;

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// imageinput.cpp&lt;/span&gt;
ImageInput&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ImageInput_Open(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; filename, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; ImageSpec _config) {
std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s_filename(filename);
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; (ImageInput_) OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageInput&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;open(
s_filename,
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageSpec&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt;(config));
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; ImageInput_format_name(ImageInput &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;in) {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;[OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageInput&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;](OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageInput&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;)(in)&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;format_name();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, we make an opaque &lt;code&gt;ImageInput\*&lt;/code&gt; available to Go, and create a shim layer that is C compatible. &lt;code&gt;ImageInput_Open()&lt;/code&gt; is a factory function that wraps the static C++ &lt;code&gt;ImageInput::open()&lt;/code&gt; equivalent. We just cast between our pointer and theirs (OIIO&amp;rsquo;s), in order to call functions and methods.&lt;/p&gt;

&lt;p&gt;But like I said, these are Go bindings on top of C/C++ libraries. What about exposing a C++ library on top of a pure Go library?&lt;/p&gt;

&lt;h2 id=&#34;exposing-go-libraries-to-c&#34;&gt;Exposing Go libraries to C++&lt;/h2&gt;

&lt;p&gt;I had previously written a Go library called &lt;a href=&#34;https://github.com/justinfx/gofileseq&#34;&gt;gofileseq&lt;/a&gt;. This library also caters to the Visual Effects industry, providing a way to build, parse, and find sequences of files, and frame ranges. Such as dealing with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/path/to/some/file_foo.0100.exr
/path/to/some/file_foo.1-100#.jpg
/path/to/some/file_foo.1-50x2,100-200x3@@@.tif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gofileseq&lt;/code&gt; library is a port of a python equivalent, &lt;a href=&#34;https://github.com/sqlboy/fileseq&#34;&gt;fileseq&lt;/a&gt;, which I help to maintain. If the parsing rules need to be updated in the Python library, they should also be updated to match in the Go library, to maintain compatibility.&lt;/p&gt;

&lt;p&gt;I had been asked more than once by colleagues if a C++ version of fileseq was available. It wasn&amp;rsquo;t, and I also didn&amp;rsquo;t want to have to maintain a 3rd standalone port that should follow the same behavior as the other two. But since the introduction of the &lt;a href=&#34;https://golang.org/doc/go1.5#link&#34;&gt;Go &lt;/a&gt;&lt;code&gt;[-buildmode](https://golang.org/doc/go1.5#link)&lt;/code&gt; flag in 1.5, it has become possible to export functions from Go to C/C++&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// sum.go&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;package&lt;/span&gt; main

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export sum&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; sum(x, y &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; main() {

}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go build -buildmode=c-shared -o sum.so
$ ls
sum.c  sum.go sum.h  sum.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a shared library and a header file, to use in our C app&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// sum.c&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\#&lt;/span&gt;include &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;stdio.h&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\#&lt;/span&gt;include &lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;sum.h&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; main(&lt;span style=&#34;color: #902000&#34;&gt;void&lt;/span&gt;) {

    &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; z &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; sum(&lt;span style=&#34;color: #40a070&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #40a070&#34;&gt;2&lt;/span&gt;);
    printf(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;1+2=%d&lt;/span&gt;&lt;span style=&#34;color: #4070a0; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;&lt;/span&gt;, z);
    
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;;

}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gcc sum.c sum.so -o sum &amp;amp;&amp;amp; ./sum
1+2=3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks pretty straight-forward, right? It would seem so until you encounter the need to export instances of your types from Go to C, and these types contain pointers to other types. You see, there are certain rules about what you can do when communicating via cgo. And these rules were &lt;a href=&#34;https://golang.org/cmd/cgo/#hdr-Passing_pointers&#34;&gt;made official as off Go 1.6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some of those rules are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can pass Go pointers to C, but C should not hang on to them beyond the scope of the call.&lt;/li&gt;
&lt;li&gt;You can not pass memory to C that contains pointers. That is, a struct which has pointer fields.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These pose an issue if you want to be able to have your C++ library create instances of objects in Go and hang on to them longer than the Go function call. In the case of &lt;code&gt;gofileseq&lt;/code&gt;, the main two objects are &lt;code&gt;[FileSequence](https://godoc.org/github.com/justinfx/gofileseq#FileSequence)&lt;/code&gt; and &lt;code&gt;[FrameSet](https://godoc.org/github.com/justinfx/gofileseq#FrameSet)&lt;/code&gt;. These are constructed from strings, perform parsing, and maintain private state. So a user would want to construct them and keep them around until they are done calling methods on them. But according to the cgo rules, I can&amp;rsquo;t give a pointer to C++ for it to hang on to indefinitely, and I can&amp;rsquo;t create a C struct in a shim to populate, because there are more internal pointers involved in a &lt;code&gt;FileSequence&lt;/code&gt;. Basically I saw this as a more complex type than just a struct with simple data fields.&lt;/p&gt;

&lt;p&gt;How do I construct these instances for C++? I created package-private maps using generated &lt;code&gt;uint64&lt;/code&gt; keys, and the instances as values. Actually, I wrap the instances up in a struct that also tracks reference counts. This allows C++ to manage the lifetime of the objects.&lt;/p&gt;

&lt;p&gt;The full implementation is located here: &lt;a href=&#34;https://github.com/justinfx/gofileseq/tree/master/cpp&#34;&gt;github.com/justinfx/gofileseq/cpp&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; FileSeqId &lt;span style=&#34;color: #902000&#34;&gt;uint64&lt;/span&gt;

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; fileSeqRef &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fileseq.FileSequence
refs &lt;span style=&#34;color: #902000&#34;&gt;uint32&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; fileSeqMap &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
lock &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;sync.RWMutex
m    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;map&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;[FileSeqId&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;]&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fileSeqRef
rand idMaker
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; idMaker &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;interface&lt;/span&gt; {
Uint64() &lt;span style=&#34;color: #902000&#34;&gt;uint64&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; (m &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;frameSetMap) Incref(id FrameSetId) {
&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// Inc refs&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; (m &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;frameSetMap) Decref(id FrameSetId) {
&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// Dec refs&lt;/span&gt;
&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// If refs == 0, delete from map&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now when C++ wants to create a &lt;code&gt;FileSequence&lt;/code&gt;, they can call a &lt;code&gt;New&lt;/code&gt; function which will create an instance, add it to the map, and return a uint64 id handle&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export FileSequence_New&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; FileSequence_New(frange &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;C.char) (FileSeqId, Error) {
fs, e &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; fileseq.NewFileSequence(C.GoString(frange))
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; e &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;nil&lt;/span&gt; {
&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// err string is freed by caller&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;, C.CString(e.Error())
}

    id &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; sFileSeqs.Add(fs)
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; id, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;nil&lt;/span&gt;

}

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export FileSequence_Dirname&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; FileSequence_Dirname(id FileSeqId) &lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;C.char {
fs, ok &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; sFileSeqs.Get(id)
&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// caller must free string&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; !ok {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; C.CString(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
}
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; C.CString(fs.Dirname())
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can see here that because this is C++ calling Go, we aren&amp;rsquo;t able to free the C string from Go, as the string needs to outlive the Go call. We just make sure that C++ always frees &lt;code&gt;\*C.char&lt;/code&gt; when it is returned. To make sure I always clean up the &lt;code&gt;char\*&lt;/code&gt; in C++, I made a helper &lt;code&gt;StringProxy&lt;/code&gt; class which wraps it and cleans it up in the destructor:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ref:&lt;/em&gt; &lt;a href=&#34;https://github.com/justinfx/gofileseq/blob/master/cpp/private/fileseq_p.h#L16&#34;&gt;_github.com/justinfx/gofileseq/cpp/private/fileseq&lt;em&gt;p.h&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0e84b5; font-weight: bold&#34;&gt;StringProxy&lt;/span&gt; {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;
StringProxy(&lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; managed) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; m_data(managed), m_str() {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (managed &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;) {
m_str.assign(managed);
}
}

    &lt;span style=&#34;color: #666666&#34;&gt;~&lt;/span&gt;StringProxy() {
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (m_data &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;) {
            free(m_data);
            m_data &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//...&lt;/span&gt;

};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This all ended up working fine! I created some benchmarks to compare fileseq between Python, C++, and Go. The test involved looping 100k times, creating a FileSequence, and calling 4 methods on it.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;100000&lt;/span&gt;;

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; n; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i) {
fileseq&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;FileSequence fs(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;/path/to/file_name.1-100x2#.ext&amp;quot;&lt;/span&gt;);
str &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.string();
str &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.frameRange();
num &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.start();
num &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.end();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;Python:  8.0s
    Go:  1.9s
   C++:  3.2s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a bit of overhead in the C++ lib from the fact that they are bindings on top of a Go layer, but I think the win for me is that it is still an acceptable level of performance and I don&amp;rsquo;t have to maintain a 3rd standalone port of fileseq!&lt;/p&gt;

&lt;p&gt;It bothered me a little that I did have to rely on a mutex-guarded static map, so I &lt;a href=&#34;https://groups.google.com/d/topic/golang-nuts/kLRFdycy0yc/discussion&#34;&gt;asked on go-nuts about an alternative approach&lt;/a&gt;. Ian Lance Taylor confirmed that the guarded map approach, with opaque ids as keys, was a completely viable approach to solving this problem. But that in some circumstance it can also be possible to malloc C memory to back Go objects, in which case they are not tracked by Go&amp;rsquo;s GC.&lt;/p&gt;

&lt;p&gt;i.e., something like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #002070; font-weight: bold&#34;&gt;fs&lt;/span&gt; :&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;\&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;FileSequence)unsafe.Pointer(
C.malloc(unsafe.Sizeof(FileSequence{})))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I tried to apply this approach, but it became really tedious and confusing to figure out how to malloc all of the internal data nested in the types. For instance, &lt;code&gt;FrameSet&lt;/code&gt; has methods that create more data along the way. And I had no idea how to cleanly get it to keep malloc&amp;rsquo;ing memory so the entire structure continues to be 100% managed by C++. So I gave up on trying this route, although I bet it would work for less nested structs.&lt;/p&gt;

&lt;p&gt;If anyone has any suggestions on another way to improve the process of exporting instances of Go objects to C++, I would definitely welcome feedback! And for anyone wanting to make their Go libraries available to C++, I hope this overview has been useful!&lt;/p&gt;</description>
    </item>
    
    
    
    <item>
      <title>SublimeText Editor and Clang (C&#43;&#43;)</title>
      <link>http://justinfx.com/2016/04/17/sublimetext-editor-and-clang/</link>
      <pubDate>2006-01-02 15:04:05 &#43;0000 MST</pubDate>
      
      <guid>http://justinfx.com/2016/04/17/sublimetext-editor-and-clang/</guid>
      <description>

&lt;p&gt;My code editor of choice has been &lt;a href=&#34;https://www.sublimetext.com&#34;&gt;SublimeText&lt;/a&gt; for a while now. It is blazing fast for searching and doing matching, replacements, and refactoring. I also love that it is very lightweight, so that I can use it as my default shell &lt;code&gt;$EDITOR&lt;/code&gt;, and also have an alias &lt;code&gt;st&lt;/code&gt; which can easily open files and folders in the current or new Sublime window:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Add directory to current sublime
$ st -a /path/to/src
# Open a new sublime window, with the current directory
$ st -n .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sublime is cross-platform, which means I can have the same development environment across Linux and OSX. It also has an amazing python-based plugin framework, which is enriched by the plugin manager and plugin community, &lt;a href=&#34;https://packagecontrol.io/&#34;&gt;PackageControl&lt;/a&gt;. While it is not a full-fledged IDE, because of the availability of so many plugin options, you can get it pretty close to being like an IDE for a number of different languages. Currently I use it for Python, Go, Markdown editing, and C++. This post outlines some simple steps for configuration a SublimeText3 project for use with C++.&lt;/p&gt;

&lt;p&gt;Before we get into the specifics of C++ configuration, let me first give a quick overview of my SublimeText3 setup, across all of my language&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/Anaconda&#34;&gt;Anaconda&lt;/a&gt; - Python language Auto-complete, Goto Definition, and Documentation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/Cython%2B&#34;&gt;Cython+&lt;/a&gt; - Cython language Syntax support&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/GoOracle&#34;&gt;GoOracle&lt;/a&gt; - Go language support for using &amp;ldquo;Oracle&amp;rdquo; tool&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/GoSublime&#34;&gt;GoSublime&lt;/a&gt; - IDE-like support for Go language&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/Markdown%20Preview&#34;&gt;Markdown Preview&lt;/a&gt; - Markdown highlighting and previewing&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/MayaSublime&#34;&gt;MayaSublime&lt;/a&gt; - Written by myself; Send Python/MEL code into Maya&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/Pretty%20JSON&#34;&gt;PrettyJSON&lt;/a&gt; - Reformatting and validating JSON&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/SideBarEnhancements&#34;&gt;SideBarEnhancements&lt;/a&gt; - Amp up the side bar and context menu&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecontrol.io/packages/ThriftSyntax&#34;&gt;ThriftSyntax&lt;/a&gt; - Syntax highlighting for &lt;a href=&#34;https://thrift.apache.org/&#34;&gt;Apache Thrift&lt;/a&gt; spec files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And the ones we will be looking at today, for C++ support:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#clang-complete&#34;&gt;Clang-Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#switch-file-deluxe&#34;&gt;Switch File Deluxe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#uncrustify&#34;&gt;Uncrustify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These steps were performed on an OSX laptop, so you will need to look at the specific README files for Linux/Windows details. I also assume you have installed Package Control, which makes it trivial to install plugins.&lt;/p&gt;

&lt;h2 id=&#34;a-name-clang-complete-clang-complete-a&#34;&gt;&lt;a name=&#34;clang-complete&#34;&gt;Clang-Complete&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;OSX already comes with the clang compiler, and this plugin for SublimeText3 allows your source to be compiled on the fly and have diagnostic details made available.&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&#34;https://packagecontrol.io/packages/Clang-Complete&#34;&gt;Clang-Complete&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There aren&amp;rsquo;t any plugin settings to adjust, but you will want to set up either general clang settings, or project-specific clang settings. General settings may be include paths related to finding system libraries, however in my case I only set up project specific settings.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Project -&amp;gt; Edit Project&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t already have a &lt;code&gt;settings&lt;/code&gt; key, create one, and then under that create a &lt;code&gt;cc_include_options&lt;/code&gt; list of flags to pass to clang. Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;settings&amp;quot;: {
	&amp;quot;cc_include_options&amp;quot;: [
		&amp;quot;-I/path/to/some/library/include&amp;quot;
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The setting is called &amp;ldquo;cc_include_options&amp;rdquo;, but it is a bit misleading. Really it seems to just be any compiler flags you want to pass to clang. I have put &lt;code&gt;-D&lt;/code&gt; macro defines, as well as being able to disable warnings, etc, etc.&lt;/p&gt;

&lt;p&gt;Once you have your basic includes entered for your given project, you should review your key mappings. There is only one I cared about:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;command&amp;quot;: &amp;quot;clang_goto_def&amp;quot;, &amp;quot;keys&amp;quot;: [&amp;quot;super+.&amp;quot;, &amp;quot;super+g&amp;quot;],
    &amp;quot;context&amp;quot;: [{&amp;quot;key&amp;quot;: &amp;quot;selector&amp;quot;, &amp;quot;operator&amp;quot;: &amp;quot;equal&amp;quot;, &amp;quot;operand&amp;quot;: &amp;quot;source.c++&amp;quot;} ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adjust the &amp;ldquo;keys&amp;rdquo; sequence as needed. This gives you the ability to jump to definitions from a given symbol.&lt;/p&gt;

&lt;p&gt;At this point, you should have code completion, and the ability to navigate through C++ symbols. You will know your code completion is working if the completion popup has more than just names, and actually has type information on the right side.&lt;/p&gt;

&lt;h2 id=&#34;a-name-switch-file-deluxe-switch-file-deluxe-a&#34;&gt;&lt;a name=&#34;switch-file-deluxe&#34;&gt;Switch File Deluxe&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This is a pretty sweet and simple plugin that lets you switch between headers and source files. Before Sublime, I had been using Qt Creator for C++ Qt projects, and this functionality was built-in and mapped to the F4 key.&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&#34;https://packagecontrol.io/packages/Switch%20File%20Deluxe&#34;&gt;Switch File Deluxe&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once installed, all I had to do was map a key sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ 
    &amp;quot;command&amp;quot;: &amp;quot;switch_file_deluxe&amp;quot;, &amp;quot;keys&amp;quot;: [&amp;quot;f4&amp;quot;], 
    &amp;quot;args&amp;quot;: {
        &amp;quot;extensions&amp;quot;: [
            &amp;quot;.cpp&amp;quot;, &amp;quot;.cxx&amp;quot;, &amp;quot;.cc&amp;quot;, &amp;quot;.c&amp;quot;, &amp;quot;Qt.cpp&amp;quot;, &amp;quot;Qt.h&amp;quot;, 
            &amp;quot;.hpp&amp;quot;, &amp;quot;.hxx&amp;quot;, &amp;quot;.h&amp;quot;, &amp;quot;_p.h&amp;quot;, &amp;quot;_p_p.h&amp;quot;, &amp;quot;.ipp&amp;quot;, 
            &amp;quot;.inl&amp;quot;, &amp;quot;.m&amp;quot;, &amp;quot;.mm&amp;quot;
        ]
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From any C++ header or source file, when you hit F4 you will switch to the corresponding header or source. If the matching file is ambiguous, you should be presented with a choice of files. Once you select the file, future uses of the key will immediately switch between the previously selected files.&lt;/p&gt;

&lt;h2 id=&#34;a-name-uncrustify-uncrustify-a&#34;&gt;&lt;a name=&#34;uncrustify&#34;&gt;Uncrustify&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;If you prefer your C++ source code to follow a particular style, then you can use the &amp;ldquo;uncrustify&amp;rdquo; tool to apply beautification based on a configuration file of rules.&lt;/p&gt;

&lt;p&gt;First I installed uncrustify via homebrew:  &lt;code&gt;brew install uncrustify&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, install &lt;a href=&#34;https://packagecontrol.io/packages/Uncrustify&#34;&gt;Uncrustify&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If your uncrustify binary is in a non-standard location, you can set the user settings for the plugin with &lt;code&gt;uncrustify_executable&lt;/code&gt;. For setting up projects to match configs, I actually used the &lt;code&gt;uncrustify_config_by_filter&lt;/code&gt; setting to set up a list of patterns:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
	&amp;quot;uncrustify_filtering_rule&amp;quot;: 1,
	&amp;quot;uncrustify_config_by_filter&amp;quot;: [
		{&amp;quot;/path/to/some/*/project&amp;quot;: &amp;quot;/path/to/project/uncrustify.cfg&amp;quot;}
	]	
}

It helps to store your uncrustify.cfg within your project repo. Also, there is a tool I used for visually editing the rules for setting up an uncrustify config: [universalindent](http://universalindent.sourceforge.net/).
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-system&#34;&gt;Build System&lt;/h2&gt;

&lt;p&gt;On a per-project basis, you can set up your build commands. Going into &lt;code&gt;Project -&amp;gt; Edit Project&lt;/code&gt;, I added something like the following to work with my particular build system for the project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;build_systems&amp;quot;: [
    {
      &amp;quot;file_regex&amp;quot;: &amp;quot;(\\S*?):(\\d+):(\\d+): (error.*)&amp;quot;,
      &amp;quot;name&amp;quot;: &amp;quot;Default &#39;Project&#39; Build&amp;quot;,
      &amp;quot;shell&amp;quot;: true,
      &amp;quot;shell_cmd&amp;quot;: &amp;quot;./\\$USER/scripts/build_cmd arg1 arg2&amp;quot;,
      &amp;quot;variants&amp;quot;: [
        {
          &amp;quot;cmd&amp;quot;: [
            &amp;quot;./\\$USER/scripts/build_cmd arg3 arg4&amp;quot;
          ],
          &amp;quot;name&amp;quot;: &amp;quot;&#39;Project&#39; Build Debug&amp;quot;,
          &amp;quot;shell&amp;quot;: true
        }
      ],
      &amp;quot;working_dir&amp;quot;: &amp;quot;/path/to/project/root&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;file_regex&lt;/code&gt; is a pattern specifying how to capture the filename, line number, column number, and error message from the output of the build command. This is useful to adapt to any kind of build system and have Sublime give you context about the errors in your view.&lt;/p&gt;

&lt;p&gt;You specify the default build command, and then optionally a number of variants for the build system, such as debug builds or different options. Once this is entered you can now set your build system selection and use your build hotkey.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t do much debugging from within my editor (I am primarily an Editor+Terminal kind of developer), so I didn&amp;rsquo;t go as far as to investigate Sublime options for debugging. But with a pretty minimal amount of configuration, I have a pretty lightweight and capable editor for working on C++ projects. And it is the same editor I use for working on Python and Go projects.&lt;/p&gt;

&lt;p&gt;Got any other recommendations for making SublimeText an even more capable solution for C++ projects? Let me know!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Comparing performance of Qt smart pointer options</title>
      <link>http://justinfx.com/2015/06/07/comparing-performance-of-qt-smart-pointer-options/</link>
      <pubDate>2006-01-02 15:04:05 &#43;0000 MST</pubDate>
      
      <guid>http://justinfx.com/2015/06/07/comparing-performance-of-qt-smart-pointer-options/</guid>
      <description>

&lt;p&gt;There are a number of sources of information on the usage and behavioral differences of the many &amp;#8220;smart pointer&amp;#8221; options offered by Qt. But one thing I couldn&amp;#8217;t find enough information on were the performance characteristics.&lt;/p&gt;

&lt;p&gt;&amp;#8220;&lt;a href=&#34;http://www.macieira.org/blog/2012/07/continue-using-qpointer/&#34;&gt;Continue Using QPointer&lt;/a&gt;&amp;#8221; describes the complicated situation that came about when the Qt project was choosing to either deprecate QPointer vs QWeakPointer APIs in Qt5, and ultimately how QPointer was preserved. It also describes how in Qt4, the QPointer has a large performance hit vs its improved backend in Qt5. So basically it says to choose performance vs compatibility.&lt;/p&gt;

&lt;p&gt;&amp;#8220;&lt;a href=&#34;http://stackoverflow.com/questions/5026197/what-c-smart-pointer-implementations-are-available/5026705#5026705&#34;&gt;What C++ Smart Pointer Implementations are available?&lt;/a&gt;&amp;#8220;, on StackOverflow, offers a pretty nice breakdown of not only the Qt smart pointers, but also other available options via Boost and C++11.&lt;/p&gt;

&lt;p&gt;I was in a situation where an existing code base had a number of basic classes that were stored in very large parent/child relationships, as pointers. Once I needed to start sharing pointers between some newer classes, I pretty quickly ran into issues of dangling pointers when relationships would change and objects would get deleted, and it seemed that a proper solution would be to introduce some sort of guarded/smart pointer in the mix. Each of a number of options have their own pros and cons. My first approach was just to use a QPointer at the point of creation, and only change the signature of functions that really needed to receive the QPointer. But I was concerned about performance, since more than one source referenced just how slow QPointer can be. But I didn&amp;#8217;t want to just switch to a QWeakPointer because of the deprecation in Qt5. So I ended up doing some benchmarks and figured this information might round out the rest of the available info on the web.&lt;/p&gt;

&lt;p&gt;The test for my benchmark involved creating a number objects, adding them to a list, and then deleting them. The options for the test include both pointers to a basic struct and a QObject, QPointers, QSharedPointers, QWeakPointers, and just for an external comparison I also included boost::shared_ptr and boost::weak_ptr. The test was performed with different numbers of objects, as well as for both Qt4 and Qt5. Here is a more detailed description of each test.&lt;/p&gt;

&lt;h4 id=&#34;the-test-environment&#34;&gt;The Test Environment&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;OSX 10.9.5 Laptop  
2.8 Ghz Intel Core 2 Duo
8 GB 1067 Mhz DDR3 memory
Clang x86 64bit
Qt 4.8.6
Qt 5.4.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;description-of-tests&#34;&gt;Description of Tests&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;test_raw_pointer&lt;/em&gt; : Creating pointers to a basic struct, adding the raw pointers to a QList, and then deleting all of the pointers&lt;/p&gt;

&lt;p&gt;&lt;em&gt;test_raw_qobject&lt;/em&gt; : Creating pointers to QObject instances, adding them to a QList, and then deleting all of the pointers&lt;/p&gt;

&lt;p&gt;&lt;em&gt;test_ptr_qsharedpointer&lt;/em&gt; : Creating QSharedPointers to a basic struct, and also a QWeakPointer for each, and adding the shared pointers to a QList. Then deleting them all.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;test_qobj_qsharedpointer&lt;/em&gt; : Creating QSharedPointers to a QObject, and also a QWeakPointer for each, and adding the shared pointers to a QList. Then deleting them all.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;test_qobj_qweakpointer&lt;/em&gt; : Creating QWeakPointers directly from QObject instances, adding them to a QList, and then deleting them all. This test could only be performed in Qt4, because Qt5 deprecated QObject tracking support for QWeakPointers, which can now only be used with QSharedPointer&lt;/p&gt;

&lt;p&gt;_test&lt;em&gt;qpointer&lt;/em&gt; : Creating QPointers directly from QObject instances, adding them to a QList, and then deleting them all.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;test_boost_sharedptr&lt;/em&gt; : Creating &lt;code&gt;boost::shared_ptrs&lt;/code&gt; from basic struct instances, as well as boost::weak_ptrs for each, adding the shared_ptrs to a QList, and then deleting them&lt;/p&gt;

&lt;p&gt;_test_boost_qobj&lt;em&gt;sharedptr&lt;/em&gt; : Creating &lt;code&gt;boost::shared_ptrs&lt;/code&gt; from QObject instances, as well as boost::weak_ptrs for each, adding the shared_ptrs to a QList, and then deleting them&lt;/p&gt;

&lt;h4 id=&#34;the-test-results&#34;&gt;The Test Results&lt;/h4&gt;

&lt;pre class=&#34;&#34;&gt;Testing w/ 5000 objects        Qt4       Qt5
=============================================
test_raw_pointer:              1 ms      1 ms
test_raw_qobject:              4 ms      3 ms 
test_ptr_qsharedpointer:       3 ms      3 ms 
test_qobj_qsharedpointer:     13 ms      6 ms
test_qobj_qweakpointer:        6 ms      -
test_qpointer:                 8 ms      7 ms
test_boost_sharedptr:          5 ms      3 ms
test_boost_qobj_sharedptr:     6 ms      4 ms

Testing w/ 50000 objects
=============================================
test_raw_pointer:             12 ms     10 ms
test_raw_qobject:             41 ms     35 ms
test_ptr_qsharedpointer:      32 ms     35 ms
test_qobj_qsharedpointer:     66 ms     62 ms
test_qobj_qweakpointer:       76 ms     -
test_qpointer:               103 ms     65 ms
test_boost_sharedptr:         32 ms     31 ms 
test_boost_qobj_sharedptr:    69 ms     61 ms

Testing w/ 500000 objects
=============================================
test_raw_pointer:            109 ms    107 ms
test_raw_qobject:            379 ms    329 ms
test_ptr_qsharedpointer:     352 ms    354 ms
test_qobj_qsharedpointer:    709 ms    642 ms
test_qobj_qweakpointer:      811 ms    -
test_qpointer:              1109 ms    725 ms
test_boost_sharedptr:        350 ms    346 ms
test_boost_qobj_sharedptr:   680 ms    611 ms

Testing w/ 2000000 objects
=============================================
test_raw_pointer:            417 ms    401 ms
test_raw_qobject:           1502 ms   1201 ms
test_ptr_qsharedpointer:    1933 ms   1383 ms
test_qobj_qsharedpointer:   3207 ms   2604 ms
test_qobj_qweakpointer:     3387 ms   -
test_qpointer:              5599 ms   2832 ms
test_boost_sharedptr:       1370 ms   1350 ms 
test_boost_qobj_sharedptr:  2864 ms   2453 ms&lt;/pre&gt;

&lt;a href=&#34;http://justinfx.com/wp-content/uploads/2015/06/qt4_pointers.png&#34; title data-fluidbox class=&#34;fluidbox&#34;&gt;
	&lt;img src=&#34;http://justinfx.com/wp-content/uploads/2015/06/qt4_pointers-300x157.png&#34; title alt&gt;
&lt;/a&gt;


&lt;a href=&#34;http://justinfx.com/wp-content/uploads/2015/06/qt5_pointers.png&#34; title data-fluidbox class=&#34;fluidbox&#34;&gt;
	&lt;img src=&#34;http://justinfx.com/wp-content/uploads/2015/06/qt5_pointers-300x154.png&#34; title alt&gt;
&lt;/a&gt;


&lt;p&gt;The test shows the overhead of simply going from a simple struct to a QObject, and then the further impact of introducing various smart pointers on QObjects, and also on non-QObjects where permitted.&lt;/p&gt;

&lt;p&gt;QPointer was the easiest change to introduce, because after you make the original class into a QObject subclass, you only need to change the code at the call site(s) where the pointers are created, and then only within the functions that specifically need to receive a guarded QPointer. For all the other function signatures, QPointer will automatically cast to an unguarded T* and behave exactly the same as before. But you can see from the results that the performance impact can be over 10x slower than when we originally started with our non-QObject class. In Qt5, while it is still most poorly performing option, it is not too far off from the option of a QSharePointer + QWeakPointer.&lt;/p&gt;

&lt;p&gt;The best performing option seems to be keeping the class as a non-QObject and using either QSharedPointer+QWeakPointer, or boost shared_ptr+weak_ptr. Although, this is the most intrusive change since all signatures have to be updated to accept QSharedPointer (or typedef).&lt;/p&gt;

&lt;p&gt;In between, using a QWeakPointer with direct QObject tracking seems like a balance between the ease of slotting it in to the existing code, and performance. The classes would still need to be QObject subclasses, but only the specific functions that need a QWeakPointer would need to change. Unfortunately this is not supported anymore in Qt5 (as only the QSharedPointer support is allowed), so it becomes a choice of whether the code needs to stay clean for future compatibility, or if one just wants to make the change later when a Qt5 migration actually happens.&lt;/p&gt;

&lt;p&gt;For a small number of object creations/deletions, the performance difference doesn&amp;#8217;t seem like it would matter that much, but when it involves tons of objects it might be a problem. If your classes were already QObjects then there are less options to consider in the first place. And the more performant route, if you don&amp;#8217;t care about the amount of code that has to change, would probably be to shoot for QSharedPointer + QWeakPointer.&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>