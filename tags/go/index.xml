<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>JustinFX.com</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://justinfx.com/tags/go/</link>
    <language>en-us</language>
    <author>Justin Israel</author>
    <copyright>2016 Justin Israel</copyright>
    <updated>Sat, 14 May 2016 15:53:48 NZST</updated>
    
    
    <item>
      <title>C&#43;&#43; Bindings For A Go Library</title>
      <link>http://justinfx.com/2016/05/14/cpp-bindings-for-go/</link>
      <pubDate>Sat, 14 May 2016 15:53:48 NZST</pubDate>
      <author>Justin Israel</author>
      <guid>http://justinfx.com/2016/05/14/cpp-bindings-for-go/</guid>
      <description>

&lt;p&gt;This is an overview describing my approach to creating C++ bindings around a Go library.&lt;/p&gt;

&lt;h2 id=&#34;a-bit-about-wrapping-c-c&#34;&gt;A bit about wrapping C/C++&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve had some past experience in writing cgo bindings on top of C and C++ libraries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/justinfx/openimageigo&#34;&gt;OpenImageigo&lt;/a&gt; and &lt;a href=&#34;https://github.com/justinfx/opencolorigo&#34;&gt;OpenColorigo&lt;/a&gt; - Color pipeline and image manipulation and conversion libraries relevant to the Visual Effects industry. These cgo libraries wrap C++.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Contributor&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gographics/imagick&#34;&gt;imagick&lt;/a&gt; - Bindings on top of the C-API for ImageMagick; Image manipulation&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wkschwartz/pigosat&#34;&gt;pigosat&lt;/a&gt; - Bindings on top of Picosat C-API; Satisfiability solver.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C libraries are more straight-forward to wrap, because Go can access them directly. C++, on the other hand, requires a &amp;ldquo;shim&amp;rdquo; layer written in C. This layer has to handle the calls between Go and the target C++ library. An example would be to treat a C++ class as an opaque pointer and provide C functions that accept the pointer and delegate to the C++ methods. Or to convert between vectors and arrays:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ref: &lt;a href=&#34;https://github.com/justinfx/openimageigo/blob/master/cpp/oiio.h&#34;&gt;github.com/justinfx/openimageigo/cpp/oiio.h&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// oiio.h&lt;/span&gt;
&lt;span style=&#34;color: #007020&#34;&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt; {
&lt;span style=&#34;color: #007020&#34;&gt;#endif&lt;/span&gt;

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;void&lt;/span&gt; ImageInput;

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// imageinput.cpp&lt;/span&gt;
ImageInput&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;ImageInput_Open&lt;/span&gt;(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; filename, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; ImageSpec &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;config) {
	std&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;string s_filename(filename);
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; (ImageInput&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;) OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageInput&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;open(
		s_filename, 
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageSpec&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt;(config));
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;ImageInput_format_name&lt;/span&gt;(ImageInput &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;in) {
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static_cast&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt;OIIO&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;ImageInput&lt;span style=&#34;color: #666666&#34;&gt;*&amp;gt;&lt;/span&gt;(in)&lt;span style=&#34;color: #666666&#34;&gt;-&amp;gt;&lt;/span&gt;format_name();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, we make an opaque &lt;code&gt;ImageInput*&lt;/code&gt; available to Go, and create a shim layer that is C compatible. &lt;code&gt;ImageInput_Open()&lt;/code&gt; is a factory function that wraps the static C++ &lt;code&gt;ImageInput::open()&lt;/code&gt; equivalent. We just cast between our pointer and theirs (OIIO&amp;rsquo;s), in order to call functions and methods.&lt;/p&gt;

&lt;p&gt;But like I said, these are Go bindings on top of C/C++ libraries. What about exposing a C++ library on top of a pure Go library?&lt;/p&gt;

&lt;h2 id=&#34;exposing-go-libraries-to-c&#34;&gt;Exposing Go libraries to C++&lt;/h2&gt;

&lt;p&gt;I had previously written a Go library called &lt;a href=&#34;https://github.com/justinfx/gofileseq&#34;&gt;gofileseq&lt;/a&gt;. This library also caters to the Visual Effects industry, providing a way to build, parse, and find sequences of files, and frame ranges. Such as dealing with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/path/to/some/file_foo.0100.exr
/path/to/some/file_foo.1-100#.jpg
/path/to/some/file_foo.1-50x2,100-200x3@@@.tif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gofileseq&lt;/code&gt; library is a port of a python equivalent, &lt;a href=&#34;https://github.com/sqlboy/fileseq&#34;&gt;fileseq&lt;/a&gt;, which I help to maintain. If the parsing rules need to be updated in the Python library, they should also be updated to match in the Go library, to maintain compatibility.&lt;/p&gt;

&lt;p&gt;I had been asked more than once by colleagues if a C++ version of fileseq was available. It wasn&amp;rsquo;t, and I also didn&amp;rsquo;t want to have to maintain a 3rd standalone port that should follow the same behavior as the other two. But since the introduction of the &lt;a href=&#34;https://golang.org/doc/go1.5#link&#34;&gt;Go &lt;code&gt;-buildmode&lt;/code&gt;&lt;/a&gt; flag in 1.5, it has become possible to export functions from Go to C/C++&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// sum.go&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;package&lt;/span&gt; main

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export sum&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; sum(x, y &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; {
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; main() {

}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go build -buildmode=c-shared -o sum.so
$ ls
sum.c  sum.go sum.h  sum.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a shared library and a header file, to use in our C app&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// sum.c&lt;/span&gt;
&lt;span style=&#34;color: #007020&#34;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #007020&#34;&gt;#include &amp;quot;sum.h&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color: #902000&#34;&gt;void&lt;/span&gt;) {

	&lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; z &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; sum(&lt;span style=&#34;color: #40a070&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #40a070&#34;&gt;2&lt;/span&gt;);
	printf(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;1+2=%d&lt;/span&gt;&lt;span style=&#34;color: #4070a0; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;&lt;/span&gt;, z);

	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gcc sum.c sum.so -o sum &amp;amp;&amp;amp; ./sum
1+2=3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks pretty straight-forward, right? It would seem so until you encounter the need to export instances of your types from Go to C, and these types contain pointers to other types. You see, there are certain rules about what you can do when communicating via cgo. And these rules were &lt;a href=&#34;https://golang.org/cmd/cgo/#hdr-Passing_pointers&#34;&gt;made official as off Go 1.6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some of those rules are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can pass Go pointers to C, but C should not hang on to them beyond the scope of the call.&lt;/li&gt;
&lt;li&gt;You can not pass memory to C that contains pointers. That is, a struct which has pointer fields.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These pose an issue if you want to be able to have your C++ library create instances of objects in Go and hang on to them longer than the Go function call. In the case of &lt;code&gt;gofileseq&lt;/code&gt;, the main two objects are &lt;a href=&#34;https://godoc.org/github.com/justinfx/gofileseq#FileSequence&#34;&gt;&lt;code&gt;FileSequence&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://godoc.org/github.com/justinfx/gofileseq#FrameSet&#34;&gt;&lt;code&gt;FrameSet&lt;/code&gt;&lt;/a&gt;. These are constructed from strings, perform parsing, and maintain private state. So a user would want to construct them and keep them around until they are done calling methods on them. But according to the cgo rules, I can&amp;rsquo;t give a pointer to C++ for it to hang on to indefinitely, and I can&amp;rsquo;t create a C struct in a shim to populate, because there are more internal pointers involved in a &lt;code&gt;FileSequence&lt;/code&gt;. Basically I saw this as a more complex type than just a struct with simple data fields.&lt;/p&gt;

&lt;p&gt;How do I construct these instances for C++? I created package-private maps using generated &lt;code&gt;uint64&lt;/code&gt; keys, and the instances as values. Actually, I wrap the instances up in a struct that also tracks reference counts. This allows C++ to manage the lifetime of the objects.&lt;/p&gt;

&lt;p&gt;The full implementation is located here: &lt;a href=&#34;https://github.com/justinfx/gofileseq/tree/master/cpp&#34;&gt;github.com/justinfx/gofileseq/cpp&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; FileSeqId &lt;span style=&#34;color: #902000&#34;&gt;uint64&lt;/span&gt;

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; fileSeqRef &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fileseq.FileSequence
	refs &lt;span style=&#34;color: #902000&#34;&gt;uint32&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; fileSeqMap &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;struct&lt;/span&gt; {
	lock &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;sync.RWMutex
	m    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;map&lt;/span&gt;[FileSeqId]&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;fileSeqRef
	rand idMaker
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;type&lt;/span&gt; idMaker &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;interface&lt;/span&gt; {
	Uint64() &lt;span style=&#34;color: #902000&#34;&gt;uint64&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; (m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;frameSetMap) Incref(id FrameSetId) {
	&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// Inc refs&lt;/span&gt;
}

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; (m &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;frameSetMap) Decref(id FrameSetId) {
	&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// Dec refs&lt;/span&gt;
	&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// If refs == 0, delete from map&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now when C++ wants to create a &lt;code&gt;FileSequence&lt;/code&gt;, they can call a &lt;code&gt;New&lt;/code&gt; function which will create an instance, add it to the map, and return a uint64 id handle&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export FileSequence_New&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; FileSequence_New(frange &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;C.char) (FileSeqId, Error) {
	fs, e &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; fileseq.NewFileSequence(C.GoString(frange))
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; e &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;nil&lt;/span&gt; {
		&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// err string is freed by caller&lt;/span&gt;
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;, C.CString(e.Error())
	}

	id &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; sFileSeqs.Add(fs)
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; id, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;nil&lt;/span&gt;
}

&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//export FileSequence_Dirname&lt;/span&gt;
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;func&lt;/span&gt; FileSequence_Dirname(id FileSeqId) &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;C.char {
	fs, ok &lt;span style=&#34;color: #666666&#34;&gt;:=&lt;/span&gt; sFileSeqs.Get(id)
	&lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// caller must free string&lt;/span&gt;
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; !ok {
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; C.CString(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
	}
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; C.CString(fs.Dirname())
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can see here that because this is C++ calling Go, we aren&amp;rsquo;t able to free the C string from Go, as the string needs to outlive the Go call. We just make sure that C++ always frees &lt;code&gt;*C.char&lt;/code&gt; when it is returned. To make sure I always clean up the &lt;code&gt;char*&lt;/code&gt; in C++, I made a helper &lt;code&gt;StringProxy&lt;/code&gt; class which wraps it and cleans it up in the destructor:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ref: &lt;a href=&#34;https://github.com/justinfx/gofileseq/blob/master/cpp/private/fileseq_p.h#L16&#34;&gt;github.com/justinfx/gofileseq/cpp/private/fileseq_p.h&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0e84b5; font-weight: bold&#34;&gt;StringProxy&lt;/span&gt; {
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt;
    StringProxy(&lt;span style=&#34;color: #902000&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; managed) &lt;span style=&#34;color: #666666&#34;&gt;:&lt;/span&gt; m_data(managed), m_str() {
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (managed &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;) {
            m_str.assign(managed);
        }
    }
    
    &lt;span style=&#34;color: #666666&#34;&gt;~&lt;/span&gt;StringProxy() {
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (m_data &lt;span style=&#34;color: #666666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;) {
            free(m_data);
            m_data &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #007020&#34;&gt;NULL&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;//...&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This all ended up working fine! I created some benchmarks to compare fileseq between Python, C++, and Go. The test involved looping 100k times, creating a FileSequence, and calling 4 methods on it.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #40a070&#34;&gt;100000&lt;/span&gt;;

&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; n; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt;i) {
    fileseq&lt;span style=&#34;color: #666666&#34;&gt;::&lt;/span&gt;FileSequence fs(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;/path/to/file_name.1-100x2#.ext&amp;quot;&lt;/span&gt;);
    str &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.string();
    str &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.frameRange();
    num &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.start();
    num &lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; fs.end();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;Python:  8.0s
    Go:  1.9s
   C++:  3.2s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a bit of overhead in the C++ lib from the fact that they are bindings on top of a Go layer, but I think the win for me is that it is still an acceptable level of performance and I don&amp;rsquo;t have to maintain a 3rd standalone port of fileseq!&lt;/p&gt;

&lt;p&gt;It bothered me a little that I did have to rely on a mutex-guarded static map, so I &lt;a href=&#34;https://groups.google.com/d/topic/golang-nuts/kLRFdycy0yc/discussion&#34;&gt;asked on go-nuts about an alternative approach&lt;/a&gt;. Ian Lance Taylor confirmed that the guarded map approach, with opaque ids as keys, was a completely viable approach to solving this problem. But that in some circumstance it can also be possible to malloc C memory to back Go objects, in which case they are not tracked by Go&amp;rsquo;s GC.&lt;/p&gt;

&lt;p&gt;i.e., something like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #002070; font-weight: bold&#34;&gt;fs&lt;/span&gt; :&lt;span style=&#34;color: #666666&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;FileSequence)unsafe.Pointer(
		C.malloc(unsafe.Sizeof(FileSequence{}))) 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I tried to apply this approach, but it became really tedious and confusing to figure out how to malloc all of the internal data nested in the types. For instance, &lt;code&gt;FrameSet&lt;/code&gt; has methods that create more data along the way. And I had no idea how to cleanly get it to keep malloc&amp;rsquo;ing memory so the entire structure continues to be 100% managed by C++. So I gave up on trying this route, although I bet it would work for less nested structs.&lt;/p&gt;

&lt;p&gt;If anyone has any suggestions on another way to improve the process of exporting instances of Go objects to C++, I would definitely welcome feedback! And for anyone wanting to make their Go libraries available to C++, I hope this overview has been useful!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go language for python programmers</title>
      <link>http://justinfx.com/2011/07/28/go-language-for-python-programmers/</link>
      <pubDate>Thu, 28 Jul 2011 00:00:00 UTC</pubDate>
      <author>Justin Israel</author>
      <guid>http://justinfx.com/2011/07/28/go-language-for-python-programmers/</guid>
      <description>

&lt;h3 id=&#34;img-class-alignleft-src-https-blog-golang-org-gopher-gopher-png-alt-width-116-height-142-http-golang-org-preface&#34;&gt;&lt;a href=&#34;http://golang.org&#34;&gt;&lt;img class=&#34;alignleft&#34; src=&#34;https://blog.golang.org/gopher/gopher.png&#34; alt=&#34;&#34; width=&#34;116&#34; height=&#34;142&#34; /&gt;&lt;/a&gt; Preface&lt;/h3&gt;

&lt;p&gt;I&amp;#8217;ve been programming in python for over 5 years now, and I love the language a lot. I would look for any opportunity to accomplish my coding tasks using python, as opposed to learning new languages. PyQt4 for user interfaces, Django for web design, etc&amp;#8230; And when python just isn&amp;#8217;t an option, I have done my share of php, javascript, objective-c and so on.&lt;/p&gt;

&lt;p&gt;Recently I started thinking that I should probably expand my programming knowledge a bit to make myself more marketable. While python is pretty key in the world of Visual Effects pipelines&amp;#8230; so is C++. Having previously focused on being a Compositor and not a programmer, I had always told myself that if I needed to learn C++, then I was going too far in that direction. But now that I have been working in pipeline development for over 2.5 years, it has become clear that I really should explore the world of compiled languages.&lt;/p&gt;

&lt;p&gt;Grabbing some books on C+, I dove in. Yuk. Why is it so freaking boring? It really does suck trying to learn C++ after having been so spoiled with python for so long. Its like taking a Aborigine and trying to turn him into a snooty English gentleman. Hmm&amp;#8230;Is that right? Well whatever. Its completely disorienting. So many things that I never had to think about, like type declarations, memory management, pointers&amp;#8230; But I kept on reading and learning.&lt;/p&gt;

&lt;p&gt;Then I came across a post on Google+, by someone that actually works at Google, mentioning a language being developed in-house. So I started reading about Go @ &lt;a href=&#34;http://golang.org/&#34;&gt;http://golang.org/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-go-language&#34;&gt;The Go Language&lt;/h3&gt;

&lt;p&gt;From the standpoint of a python programmer, Go feels like it sits right between C/C++ and python. You get the simpler syntax, but with the speed of a compiled language. Because Go has garbage collection, memory management isn&amp;#8217;t a concern. I was never used to the code/compile/test/repeat pattern before, but it compiles so fast and is so easy to set up a project that it feels pretty natural. Go doesn&amp;#8217;t require you to have header files and declare everything in advance, so banging out a simple program is quite fast and only slightly more overhead than writing a python script. Just have to add the step of compiling it. As far as the library, so far I have found everything pretty useful. And it seems that every time I search for a Go binding for something, I find one. I will go into more detail on that in a bit.&lt;/p&gt;

&lt;p&gt;One thing that will make python programmers feel more at home is the type inference while creating a variable. While you can do something like this in Go:  &lt;code&gt;var myString string = &amp;quot;Foo&amp;quot;&lt;/code&gt; you can also type the same thing like this: &lt;code&gt;myString := &amp;quot;Foo&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;:=&lt;/code&gt; operator lets you initialize a new variable and makes the compiler figure out what type it should be, based on the return type of the right hand side.&lt;/p&gt;

&lt;p&gt;Pointers are still kind of strange for python programmers, but Go is a lot more flexible about using them. You don&amp;#8217;t always have to explicitly dereference them like &lt;code&gt;(*myPointer).myFunction()&lt;/code&gt;. It just does it for you when you access member functions and attributes:  myPointer.myFunction().&lt;/p&gt;

&lt;p&gt;Having no type inheritance is also a bit different as well. Instead of creating base abstract classes, and subclassing them, you only have structs&amp;#8230; no classes. But you share functionality by using interfaces. An interface is just a definition of methods. If any object implements those methods, its consider that type of interface. This is something I have yet to really get into, since my current first project is more of a cmd program, rather than a pkg library. I&amp;#8217;m sure I could be using interfaces already, but it hasn&amp;#8217;t quite felt natural enough to incorporate as of yet.&lt;/p&gt;

&lt;p&gt;A pretty crazy aspect of Go is its native support for concurrency using what they call &amp;#8220;Goroutines&amp;#8221;. The closest way I have been able to compare it to my experience in python is while using ZeroMQ for messaging. ZeroMQ promotes not only using its library for messaging, but also to replace issues with threads and locks. It has similar concepts in promoting concurrency. You divide your program up into its components and instead of sharing data structures between them, you communicate over channels (sockets in ZeroMQ). When you fire off a Goroutine, you aren&amp;#8217;t waiting for it anymore. It can run and do its thing and you keep on going. You can then send data back and forth with channels, and even use them just for signaling, like saying &amp;#8220;ok now exit&amp;#8221;.&lt;/p&gt;

&lt;h3 id=&#34;actual-usage&#34;&gt;Actual Usage&lt;/h3&gt;

&lt;p&gt;I&amp;#8217;ve been writing a message server so far in python, using the &lt;a href=&#34;http://www.tornadoweb.org/&#34;&gt;Tornado web server&lt;/a&gt;, along with some socket.io bindings called &lt;a href=&#34;https://github.com/MrJoes/tornadio&#34;&gt;TornadIO&lt;/a&gt;, and also &lt;a href=&#34;http://www.zeromq.org/&#34;&gt;ZeroMQ&lt;/a&gt; for internal communication. So far its been working pretty well, but there are a lot of complex layers, with ZeroMQ sort of riding on top of Tornados ioloop. I decided to try and rewrite this server in Go. Turns out Go has a lot of built-in support for doing exactly what this python server was doing. The whole web-socket server functionality is part of the standard http library module. I quickly found &lt;a href=&#34;https://github.com/madari/go-socket.io&#34;&gt;Go bindings for socket.io&lt;/a&gt; and I was on my way.&lt;/p&gt;

&lt;p&gt;It was quite fast to get the server to the point of doing global messages, but now I had to think about implementing the support for channel subscriptions. My first instinct was to go grab ZeroMQ and its bindings again, or to use Redis for the messaging, but then I was thinking &amp;#8220;Shouldn&amp;#8217;t I be able to do all this with Go&amp;#8217;s concurrency?&amp;#8221;. One thing that really helped me out was how fast everyone responds on the &lt;a href=&#34;http://groups.google.com/group/golang-nuts&#34;&gt;golang-nuts discussion group&lt;/a&gt;. It was quickly pointed out by more than one person that I should definitely be able to accomplish the internal message routing purely in Go. And they were right. I just set up a &amp;#8220;dispatcher&amp;#8221; function and run it in a loop as a goroutine, and then pass messages in and out of it. The dispatcher manages its data structure, and no other part of the code accesses it directly.&lt;/p&gt;

&lt;p&gt;So far, this Go server is turning out great, and I&amp;#8217;m excited by the fact that its compiled and faster. I don&amp;#8217;t have to distribute my source code now &lt;img src=&#34;http://justinfx.com/wp-includes/images/smilies/simple-smile.png&#34; alt=&#34;:-)&#34; class=&#34;wp-smiley&#34; style=&#34;height: 1em; max-height: 1em;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Disclaimer: These numbers are just comparisons between what I built in python vs Go. I think the point is to reflect what I naturally came up with on my first pass at using Go, vs applying years of python experience. I&amp;#8217;m dead sure my Go code isn&amp;#8217;t written as efficiently as someone with more experience, which I think makes it even more interesting of a comparison.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go comes with built in testing and benchmarking functionality. What I built was a client test that connects to a running server and rapid fires messages. It times how long it takes for a 150 byte message to be sent out, flow through the server, and come back to that client as been delivered. The gotest utility that is used to run the test code will run the test, and if it ran too fast to calculate timings, it will repeat the test over and over with larger iterations. When I first got my Go server working to where a client would send a message and it would just get broadcasted right back out to everyone, I ran a benchmark. Here are the results of my tests&amp;#8230;&lt;/p&gt;

&lt;table border=&#34;0&#34; width=&#34;500px&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
  &lt;tr&gt;
    &lt;th scope=&#34;col&#34; align=&#34;left&#34; width=&#34;200&#34;&gt;
      TEST
    &lt;/th&gt;
    
    &lt;th scope=&#34;col&#34; width=&#34;150&#34;&gt;
      TIME PER MSG
    &lt;/th&gt;
    
    &lt;th scope=&#34;col&#34; width=&#34;150&#34;&gt;
      NET RESULT
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;200&#34;&gt;
      Python (Tornado, …)
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      835314 ns/op
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      &amp;#8211;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;200&#34;&gt;
      Go (barebones messaging)
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      107091 ns/op
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      7.8x faster
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;200&#34;&gt;
      Go (1-to-1 python port)
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      159823 ns/op
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      5.2x faster
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;200&#34;&gt;
      Go (weekly.12-01-2011)
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      76230 ns/op
    &lt;/td&gt;
    
    &lt;td width=&#34;150&#34;&gt;
      11x faster
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The second Go test was after I finished implementing the same 1-to-1 feature set of the python version. I had thought the numbers would be dramatically impacted after adding the overhead of all the internal message routing, but the Go server still came out almost 5x faster than the python version. And this is from my first attempt at writing a Go program! I bet once I get a lot more solid with the language I can optimize this code a lot more.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I&amp;#8217;m pretty hooked on the language. I feel its the perfect option for a python programmer that wants some speed increases and simple concurrency, without having to learn something as intense as C++. Go is supposed to get faster and faster as they improve things like the goroutines, channels, and the garbage collector, so its a great time to jump in and start learning. Its really helped me understand more formal concepts that will probably make learning C++ even easier once I decide to go back to learning it &lt;img src=&#34;http://justinfx.com/wp-includes/images/smilies/simple-smile.png&#34; alt=&#34;:-)&#34; class=&#34;wp-smiley&#34; style=&#34;height: 1em; max-height: 1em;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>