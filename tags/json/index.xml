<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>JustinFX.com</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://justinfx.com/tags/json/</link>
    <language>en-us</language>
    <author>Justin Israel</author>
    <copyright>2012 Justin Israel</copyright>
    <updated>Wed, 25 Jul 2012 00:00:00 UTC</updated>
    
    
    <item>
      <title>Python 2.7.2 serializer speed comparisons</title>
      <link>http://justinfx.com/2012/07/25/python-2-7-3-serializer-speed-comparisons/</link>
      <pubDate>Wed, 25 Jul 2012 00:00:00 UTC</pubDate>
      <author>Justin Israel</author>
      <guid>http://justinfx.com/2012/07/25/python-2-7-3-serializer-speed-comparisons/</guid>
      <description>&lt;p&gt;In a recent python project where I was sending multiple messages per second of data over a basic socket, I had initially just grabbed the cPickle module to get the prototype proof-of-concept functioning properly. cPickle is awesome for easily serializing more complex python objects like custom classes, even though in my case I am only sending basic types.&lt;/p&gt;

&lt;p&gt;My messages were dicts with some nested dicts, lists, floats, and string values. Roughly 500-1000 bytes. cPickle was doing just fine, but there came a point where I wanted to investigate the areas that could be tightened up. The first thing I realized was that I had forgotten to encode cPickle in the binary format (the default is ascii). That saved me quite a bit of time. But then I casually searched online to see if any json options might be better since my data is pretty primitive anyways.&lt;/p&gt;

&lt;p&gt;I found &lt;a href=&#34;http://pypi.python.org/pypi/ujson/&#34;&gt;UltraJSON&lt;/a&gt;, which is a pure C json parsing library for python, and ran some tests. There are benchmarks on the project page for ujson, as well as other articles on the internet, but I just wanted to post up my own results using a mixed type data container. ujson came out extremely fast: faster than binary cPickle and msgpack, in the encoding test. Although in the decoding test, msgpack appeared to be fastest, followed by binary cPickle, and then ujson coming in 3rd&lt;/p&gt;

&lt;p&gt;This test included the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/library/pickle.html#module-pickle&#34;&gt;pickle/cPickle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.org/library/json.html&#34;&gt;json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pypi.python.org/pypi/simplejson/&#34;&gt;simplejson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pypi.python.org/pypi/python-cjson/&#34;&gt;cjson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi/ujson&#34;&gt;ujson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pypi.python.org/pypi/yajl/&#34;&gt;yajl-py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pypi.python.org/pypi/msgpack-python&#34;&gt;msgpack-python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div&gt;
  Here is my Python 2.7.2 test script using timeit for each encode and decode step.
&lt;/div&gt;
&lt;br&gt;
Dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install tabulate simplejson python-cjson ujson yajl msgpack-python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test:&lt;/p&gt;


from timeit import timeit 
from tabulate import tabulate

setup = &#39;&#39;&#39;d = {
    &#39;words&#39;: &#34;&#34;&#34;
        Lorem ipsum dolor sit amet, consectetur adipiscing 
        elit. Mauris adipiscing adipiscing placerat. 
        Vestibulum augue augue, 
        pellentesque quis sollicitudin id, adipiscing.
        &#34;&#34;&#34;,
    &#39;list&#39;: range(100),
    &#39;dict&#39;: dict((str(i),&#39;a&#39;) for i in xrange(100)),
    &#39;int&#39;: 100,
    &#39;float&#39;: 100.123456
}&#39;&#39;&#39;

setup_pickle    = &#39;%s ; import cPickle ; src = cPickle.dumps(d)&#39; % setup
setup_pickle2   = &#39;%s ; import cPickle ; src = cPickle.dumps(d, 2)&#39; % setup
setup_json      = &#39;%s ; import json; src = json.dumps(d)&#39; % setup
setup_msgpack   = &#39;%s ; src = msgpack.dumps(d)&#39; % setup

tests = [
    # (title, setup, enc_test, dec_test)
    (&#39;pickle (ascii)&#39;, &#39;import pickle; %s&#39; % setup_pickle, &#39;pickle.dumps(d, 0)&#39;, &#39;pickle.loads(src)&#39;),
    (&#39;pickle (binary)&#39;, &#39;import pickle; %s&#39; % setup_pickle2, &#39;pickle.dumps(d, 2)&#39;, &#39;pickle.loads(src)&#39;),
    (&#39;cPickle (ascii)&#39;, &#39;import cPickle; %s&#39; % setup_pickle, &#39;cPickle.dumps(d, 0)&#39;, &#39;cPickle.loads(src)&#39;),
    (&#39;cPickle (binary)&#39;, &#39;import cPickle; %s&#39; % setup_pickle2, &#39;cPickle.dumps(d, 2)&#39;, &#39;cPickle.loads(src)&#39;),
    (&#39;json&#39;, &#39;import json; %s&#39; % setup_json, &#39;json.dumps(d)&#39;, &#39;json.loads(src)&#39;),
    (&#39;simplejson-3.3.1&#39;, &#39;import simplejson; %s&#39; % setup_json, &#39;simplejson.dumps(d)&#39;, &#39;simplejson.loads(src)&#39;),
    (&#39;python-cjson-1.0.5&#39;, &#39;import cjson; %s&#39; % setup_json, &#39;cjson.encode(d)&#39;, &#39;cjson.decode(src)&#39;),
    (&#39;ujson-1.33&#39;, &#39;import ujson; %s&#39; % setup_json, &#39;ujson.dumps(d)&#39;, &#39;ujson.loads(src)&#39;),
    (&#39;yajl 0.3.5&#39;, &#39;import yajl; %s&#39; % setup_json, &#39;yajl.dumps(d)&#39;, &#39;yajl.loads(src)&#39;),
    (&#39;msgpack-python-0.3.0&#39;, &#39;import msgpack; %s&#39; % setup_msgpack, &#39;msgpack.dumps(d)&#39;, &#39;msgpack.loads(src)&#39;),
]

loops = 15000
enc_table = []
dec_table = []

print &#34;Running tests (%d loops each)&#34; % loops

for title, mod, enc, dec in tests:
    print title

    print &#34;  [Encode]&#34;, enc 
    result = timeit(enc, mod, number=loops)
    enc_table.append([title, result])

    print &#34;  [Decode]&#34;, dec 
    result = timeit(dec, mod, number=loops)
    dec_table.append([title, result])

enc_table.sort(key=lambda x: x[1])
enc_table.insert(0, [&#39;Package&#39;, &#39;Seconds&#39;])

dec_table.sort(key=lambda x: x[1])
dec_table.insert(0, [&#39;Package&#39;, &#39;Seconds&#39;])

print &#34;\nEncoding Test (%d loops)&#34; % loops
print tabulate(enc_table, headers=&#34;firstrow&#34;)

print &#34;\nDecoding Test (%d loops)&#34; % loops
print tabulate(dec_table, headers=&#34;firstrow&#34;)


&lt;p&gt;OUTPUT:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Running tests (15000 loops each)
pickle (ascii)
  [Encode] pickle.dumps(d, 0)
  [Decode] pickle.loads(src)
pickle (binary)
  [Encode] pickle.dumps(d, 2)
  [Decode] pickle.loads(src)
cPickle (ascii)
  [Encode] cPickle.dumps(d, 0)
  [Decode] cPickle.loads(src)
cPickle (binary)
  [Encode] cPickle.dumps(d, 2)
  [Decode] cPickle.loads(src)
json
  [Encode] json.dumps(d)
  [Decode] json.loads(src)
simplejson-3.3.1
  [Encode] simplejson.dumps(d)
  [Decode] simplejson.loads(src)
python-cjson-1.0.5
  [Encode] cjson.encode(d)
  [Decode] cjson.decode(src)
ujson-1.33
  [Encode] ujson.dumps(d)
  [Decode] ujson.loads(src)
yajl 0.3.5
  [Encode] yajl.dumps(d)
  [Decode] yajl.loads(src)
msgpack-python-0.3.0
  [Encode] msgpack.dumps(d)
  [Decode] msgpack.loads(src)

Encoding Test (15000 loops)
Package                 Seconds
--------------------  ---------
ujson-1.33             0.232215
msgpack-python-0.3.0   0.241945
cPickle (binary)       0.305273
yajl 0.3.5             0.634148
python-cjson-1.0.5     0.680604
json                   0.780438
simplejson-3.3.1       1.04763
cPickle (ascii)        1.62062
pickle (ascii)        14.0497
pickle (binary)       15.4712

Decoding Test (15000 loops)
Package                 Seconds
--------------------  ---------
msgpack-python-0.3.0   0.240885
cPickle (binary)       0.393152
ujson-1.33             0.396875
python-cjson-1.0.5     0.694321
yajl 0.3.5             0.748369
simplejson-3.3.1       0.780531
cPickle (ascii)        1.38561
json                   1.65921
pickle (binary)        5.20554
pickle (ascii)        17.8767
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
  </channel>
</rss>